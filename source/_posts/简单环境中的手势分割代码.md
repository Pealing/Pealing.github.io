---
title:  "简单环境中的手势分割代码"
date: 2017-03-15 13:19:22
tags: [C++,Opencv,手势识别]
categories: "图像识别"
---
# 概述
    这是用OPENCV&C++在VS环境下实现的一个手的手腕取出的代码
    主要运用了最大内切圆和外接矩形来实现这一功能
    获得的结果可以通过特征提取，利用SVM来做机器学习
    总的来说分类效果还挺好的，可以达到99%的准确率
<!--more-->

*代码地址：*`https://github.com/Pealing/Gesture-Recognition-Based-HU-Moments`

### 图像预处理
#### 方法一：RGB->灰度图->二值图
    任何一种颜色可以在计算机中形成多种不同的色彩空间，常用的色彩空间有HIS模式，CMYK模式，YCbCr模式，Lab模式，HSV模式，NTSC模式等。 
通常，我们采用与彩色图像一样，反映了整幅图的整体和局部的色度和亮度等级的分布和特征的灰度图像来进行计算。将彩色图像转化为灰度图像的过程称为图像的灰度化处理。
直接利用OPENCV函数进行转换
`//原图_imgRaw，灰度图imgBin
cvtColor(_imgRaw, imgBin, CV_BGR2GRAY);`
接着，对灰度图进行操作得到二值图中，通过二值图所包含的图像信息可以获得手势的轮廓并进行特征提取。
在本次实验中，我们所获得的手势数据集处于黑色简单的背景环境中。灰度化处理后的手势图像有256个灰度级。由于背景为黑色，即灰度级为0，所以我们设定阈值为t，大于阈值的像素群的灰度值设置为255（白色），小于阈值的像素群则设置为0(黑色)。经过这样的二值化处理，我们可以得到仅有黑白两色的二值图，手势部分为白色，背景部分为黑色。
`//这里设置阈值为10
threshold(imgBin, imgBin, 10, 255, 0);`

---
#### 方法二：利用HSV空间转换获得二值图
    HSV是根据颜色直观特性创建的一种颜色空间，其中：
    * 色调H：取值范围0°~360°
    * 饱和度S：取值范围0%~100%
    * 明度V：取值范围0%~100%
    人的皮肤颜色有其一定的HSV值，因此在复杂的环境中，可以根据HSV颜色空间，来将手与周围环境分离。

```cpp
//将RGB转换成HSV空间
    cvtColor(img,hsv,CV_BGR2HSV);
    vector<Mat> a;
    //分离色彩通道
    split(hsv,a);
    Mat h=a[0];
    Mat s=a[1];
    Mat v=a[2];
    //调节HSV值
    inRange(h,6,25,a[0]);
    inRange(s,66,200,a[1]);
    inRange(v,60,200,a[2]);
    //合并调节好的三个单通道图
    bitwise_and(a[0],a[1],imb);bitwise_and(a[2],imb,imb);
```

* 这种方法下的阈值可能要经常根据环境去做一个修改，算是比较麻烦的。
* 如果各位有更好的，能够受环境因素影响较小的方法，欢迎github私我~

---
### 手掌定位和手腕分割
#### 确定手的轮廓
    这个方法比较简单也很常用，就是把二值图中的所有轮廓面积一个一个计算，选择最大的一个保留,剩下的全部用
    `drawContours(_imgBin, _contours, index, Scalar(0,0,0), -1, 8);`
    "涂黑"就可以了。

    或者，也可以新建一张图片
    `_imgBin = Mat::zeros(_imgRaw.rows, _imgRaw.cols, CV_8UC1);`此时图片是全黑的
    之后再图片中画上最大的轮廓：
    `drawContours(_imgBin, _contours, idxMax, Scalar(255, 255, 255), -1, 8)`


#### 手掌定位
    手掌定位的方法用的是寻找最大内切圆的方法，即：我们的手的轮廓（包括手臂部分）的最大内切圆即是我们手掌的位置。

    寻找最大内切圆方法：遍历图上的每一个像素点，找到白色的像素点（手）与轮廓上的点的一个最小距离。再比较所有获得的最小距离，取最大的一个，就是内切圆的半径，这个点就是最大内切圆的圆心。
* 代码如下：
```cpp
void Gesture::_MaxCircleInContour(const Contour& contour, Point& P, double& R)
{
    P = Point(-1, -1);
    R = -1;
    for (int i = 0; i < _imgBin.rows; i += 40)
        for (int j = 0; j < _imgBin.cols; j += 40)
            if (_imgBin.at<uchar>(i, j) == 255)
            {
                double minDist = 1e66;
                for (int k = 0; k < (int)contour.size(); k += 4)
                {
                    double thisDist = dist2(contour[k], Point(j, i));
                    if (thisDist < minDist)
                    {
                        minDist = thisDist;
                    }
                }
                if (R < minDist)
                {
                    R = minDist;
                    P = Point(j, i);
                }
            }
    if (R > 0) 
        R = sqrtf(R);
}
```

* 用遍历图上每个点方法来寻找最大内切圆，讲道理，在超级高分辨率的摄像头下是挺慢的。但是目前似乎没有更好的方法？求数学大牛快想出一个新的解法吧！

---

#### 手腕冗余信息的去除
    手掌定位以后，很好，我们去除手腕的工作就完成了一大半。接下来，如何去除手腕，这个光我见过的方法就有好几种。

* 第一种是最简单的，穿个黑色的衣服，在黑色的背景下，手臂自然就会被除掉，当然在这种方法下，上述的手掌定位也就没有什么必要了。
    
* 第二种是这样的，人们认为：掌心的位置是"中指指尖到手腕连线的3/4处"，所以遍历一遍手掌轮廓，找到一个与掌心距离最远的点（且认为它是中指），连接他跟掌心的直线，距离dist（点，掌心）/3*4,其中dist()代表欧氏距离。
    - 但是这种方法有一个弊端：如果我们的手臂很长，或者是我们的手势是个拳头（没有较长的手指出现），那找到的这个最远点就会出错。

* 第三种，就是我这个小菜比自己开脑洞想的法子啦：利用外接矩形的方法来去除掉我们的手掌。

##### 算法思想
1. 给轮廓画一个外接矩形`Rect rect2 = boundingRect(_contours[idxMax]);`，该外接矩形平行于屏幕
2. `Point tl = rect2.tl();//矩形的左上方顶点
    Point br = rect2.br();//矩形的右下方顶点`
3. 手在屏幕中有4中出现情况：从屏幕的4条边框出现，也就是说，手的手腕方向永远都是与屏幕边缘通向的，即外接矩形的其中一条边是与屏幕重合的。
4. 此时我们就对矩形的顶点做一个判断，在边缘处的边即为手臂的边。此时我们把这条边像掌心位置靠拢，一直靠拢到与掌心的欧氏距离为1.5R，这个时候，我们就可以将手臂去除到我们的矩形之外了。超级厉害有木有（并不）~
5. 此时我们将矩形用`rectangle(imgBin,rect2,Scalar(0,0,0),-1);`涂黑，图片中唯一剩下的轮廓就是我们要去除的手臂啦，然后把手部分"涂黑"去除，再把手掌部分恢复，我们就可以得到去掉手臂的手掌啦~

具体代码如下：
```
bool Gesture::GetPalmImage()
{

    // 二值化
    _GetBinaryImage(_imgBin);

    // 在二值图中找出所有的轮廓
    Mat imgBin = _imgBin.clone();
    findContours(imgBin, _contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);

    // 若没有轮廓，返回false
    if (_contours.empty())
    {
        std::cerr << "[错误] 未找到轮廓。" << std::endl;
        return false;
    }
    //// 【蓝色】所有找到的轮廓
    //drawContours(_imgRaw, _contours, -1, Scalar(255, 0, 0), 2, 8);

    // 找到最大的轮廓（手）
    int idxMax = _MaxContourIndex(_contours);
    //// 【绿色】手的轮廓
    //drawContours(_imgRaw, _contours, 0, Scalar(0, 255, 0), 2, 8);

    // 在二值图中画出填充的最大轮廓
    _imgBin = Mat::zeros(_imgRaw.rows, _imgRaw.cols, CV_8UC1);
    drawContours(_imgBin, _contours, idxMax, Scalar(255, 255, 255), -1, 8);
    // 找到轮廓内最大圆的圆心P及半径R
    Point P;
    double R;
    _MaxCircleInContour(_contours[idxMax], P, R);
    if (R < 0)
    {
        std::cerr << "[错误] 未找到圆心及半径。" << std::endl;
        return false;
    }

    // 记录中心点及半径
    _Center = P;
    _CenterRadius = R;

    //画外接矩阵

    Rect rect2 = boundingRect(_contours[idxMax]);
    rectangle(_imgRaw,rect2,Scalar(255,0,0),3);
    Point tl = rect2.tl();
    Point br = rect2.br();

//利用外接矩阵切割手掌{
    int index = -1;
    Point indexPoint;
    if(br.y >= _imgRaw.rows - 5)
    {
        rect2.width = abs(tl.y - P.y) + 1.5 * R;
        indexPoint = rect2.br();;
        index = 0;
    }
    else if (br.x >= _imgRaw.cols - 5)
    {
        rect2.width = abs(tl.x - P.x) + 1.5 * R;
        indexPoint = rect2.br();;
        index = 1;
    }
    else if(tl.x <= 5)
    {
        rect2.x = (br.x - P.x);
        rect2.width = (br.x - P.x); + 1.5 * R;
        indexPoint = rect2.tl();
        index = 2;
    }
    else if(tl.y <= 5)
    {
        rect2.x = (br.y - P.y);
        rect2.width = (br.y - P.y); +1.5 *  R;
        indexPoint = rect2.tl();
        index = 3;
    }
    rectangle(_imgRaw,rect2,Scalar(255,255,0),3);
//}利用外接矩阵切割手掌

    
    // 用背景色（黑色）填充手掌矩形
    imgBin = _imgBin.clone();
    rectangle(imgBin,rect2,Scalar(0,0,0),-1);

    // 【紫色】最大圆及圆心
    circle(_imgRaw, P, (int)R, Scalar(255, 0, 255), 4);
    circle(_imgRaw, P, 10, Scalar(255, 0, 255), -1);

    // 寻找此时imgBin中的轮廓
    vector<Contour> newContours;
    findContours(imgBin, newContours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);
    if (newContours.empty())
    {
        std::cerr << "[错误] 填充矩形后，未找到轮廓。" << std::endl;
        imgBin = _imgBin.clone();
        _contours.clear();
        findContours(imgBin, _contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
        // 【红色】手掌轮廓
        drawContours(_imgRaw, _contours, 0, Scalar(0, 0, 255), 4, 8);

        if(br.y >= _imgRaw.rows - 5 || br.x >= _imgRaw.cols - 5)
            indexPoint = br;
        else if(tl.x <= 5 || tl.y <= 5) 
            indexPoint = tl;
        GetPalmPoint(_contours[0],indexPoint,index,_imgRaw.rows,_imgRaw.cols);
        AddPoint();

        return false;
    }

    // 删除所有与边界接触
    // 删除方式为，在内部二值图，用黑色填充
    double area_level = acos(-1) * R * R * 0.25;
    Contour deleteContour = _contours[idxMax];
    for(int i=0;i<(int)newContours.size();i++)
    {
        Contour &thisContour = newContours[i];
        if(_TouchedWithBoundary(thisContour, imgBin.rows, imgBin.cols))
        {
            HaveForearm  = true;
            drawContours(_imgBin, newContours, i, Scalar(0, 0, 0), -1, 8);
            deleteContour = thisContour;
        }
    }

    // 再次寻找手轮廓
    imgBin = _imgBin.clone();
    _contours.clear();
    findContours(imgBin, _contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);

    if (_contours.size() != 1u)
    {
        std::cerr << "[错误] 再次寻找手轮廓时出错，此时应该有且只有一个轮廓。" << std::endl;
        return false;
    }
    if (_contours[0].empty())
    {
        std::cerr << "[错误] 再次寻找手轮廓时出错，找到唯一一个轮廓但是为空。" << std::endl;
        return false;
    }

    // 【红色】手掌轮廓
    drawContours(_imgRaw, _contours, 0, Scalar(0, 0, 255), 4, 8);
    //寻找手腕点
    GetPalmPoint(_contours[0],indexPoint,index,_imgRaw.rows,_imgRaw.cols);
    AddPoint();

    return true;
}
```

---
至此，我们的代码也就讲解完成啦，后期博主会上点图片美化一下哒
