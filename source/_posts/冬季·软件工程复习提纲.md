---
title: 冬季·软件工程复习提纲
date: 2017-03-11 13:19:22
updated: 2017-03-11 13:19:22
tags:
categories: "冬季复习提纲"
---

<center>Pealing 
2017.3.10</center>

# 前言
    这是一份，上海大学冬季学期的软件工程复习提纲
    基本上就是把书打了一遍
    不代表权威
    写了没考到，考了没写到
    都清不要怪我，谢谢
<!--more-->

### 第一章·软件工程学概述
---
##### 软件危机
    计算机软件的开发和维护过程中所遇到的一系列严重问题

* 软件危机典型表现
    * 对软件开发成本和进度的估计常常很不准确
    * 用户对"已完成的"软件系统不满意的现象经常发生
    * 软件产品的质量往往靠不住
    * 软件常常是不可维护的
    * 软件成本在计算机系统总成本中所占的比例逐年上升
    * 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。

* 软件危机产生原因
    * 规模加大、复杂性提高
    * 软件是逻辑产品
    * 软件缺乏“可见性”
    * 不会“用坏”
    * 缺乏有效的、系统的技术手段和管理方法
    * 用户和软件开发人员的理解鸿沟
    * 错误的认识和做法
    * 忽视软件需求分析的重要性
    * 认为软件开发就是写程序并设法使之运行
    * 轻视软件维护

#### 软件工程
    软件工程是指导计算机软件开发和维护的一门工程学科。
    采用工程的概念、原理、技术和方法来开发与维护软件，
    把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，
    以经济地开发出高质量的软件并有效地维护它。

* 软件工程的本质特质
    * 软件工程关注于大型程序的构造
    * **软件工程的中心课题是控制复杂性**
    * 软件经常变化
    * 开发软件的效率非常重要
    * **和谐地合作是开发软件的关键**
    * 软件必须有效的支持它的用户

* 软件工程方法学3要素：
    方法（传统方法学、面型对象方法学）、工具、过程

* 软件生命周期：
    * 软件定义
        问题定义、可行性研究、需求分析
    * 软件开发
        总体设计、详细设计、编码、单元测试、综合测试
    * 运行维护

###### 过程模型
    生命周期模型规定了把生命周期划分成哪些阶段及
    各个阶段的执行顺序，因此，也称为过程模型。

* 瀑布模型

    特点：
    1）阶段间具有顺序性和依赖性（规范化、自动化）；
    2）推迟现实的观点（区分逻辑设计与物理设计，尽可能推迟程序的物理实现）；
    3）质量保证的观点（每个阶段都要交出合格的文档、每个阶段结束前都要对所完成的文档进行评审）。

    * 优点：
    1. 可强迫来发人员采用规范的方法
    2. 严格规定了每个阶段必须提交的文档；
    3. 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细检查

    * 瀑布模型基本上是一种文档驱动的模型

* 快速原型模型
    * 软件产品的开发基本上是线性顺序进行的
    * **应用范围**
        用户需求不完全或不准确,有快速的原型开发工具
        项目招投标时，以原型模型作为软件的开发模型
        产品移植或升级或对已有产品原型进行客户化工作

* 增量模型
    * 也称为渐增模型，把软件产品作为一系列的增量构建来设计、编码、集成和测试
* 螺旋模型
    * 使用原型及其他方法来尽量降低风险（构造原型是一种能使某些类型的风险降至最低的方法）
    * 在每个阶段之前都增加了风险分析过程的快速原型模型
    * 将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析
* 喷泉模型
    * 面向对象使用
    
---

### 第二章

---
#### 可行性研究
    可行性研究的目的不是为了解决问题，而是确定问题是否值得去解决。

* 研究可行性3个方面：
    1. 技术可行性；
    2. 经济可行性；
    3. 操作可行性；

    以及法律社会效应等
    可行性研究的**最根本任务**是对以后的行动方针提出建议。

##### 系统流程图
    进入可行性研究时需要了解和分析现有的系统，应该把设想的新系统的
    逻辑模型转变成物理模型。

* 系统流程图是概括地描绘物理系统的传统工具

##### 数据流图
    数据流图（DFD）描绘信息和数据从输入移动到输出的过程中所经受的变换
    只是描绘数据在软件流动和被处理的逻辑过程
##### 数据字典
    * 是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。
    * 最重要的是作为分析阶段的工具

---
### 第三章
---
#### 需求分析
    * 准确地回答“系统必须做什么?”
    * 分析软件需求、书写软件需求规格说明书**
    * 需要建立：数据模型、功能模型和行为模型

* 具体任务
    * 确定对系统的综合要求：
        * 功能需求：指定系统必须提供的服务，通过需求分析应该划分出系统必须完成的所有功能。
        * 性能需求：指定系统必须满足的定时约束或容量约束，通常包括速度（响应时间）、信息量速率、主存容量、磁盘容量、安全性等方面的需求。
        * 可靠性和可用性的需求：可靠性需求定量地指定系统的可靠性；可用性量化了用户的可以使用系统的程度。
        * 出错处理需求：说明系统对环境错误应该怎样响应。
        * 接口需求：描述应用系统与它的环境通信的格式。
        * 约束：设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件。
        * 逆向需求：说明软件系统不应该做什么。
        * 将来可能提出的要求：明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。
    * 分析系统的数据要求
    * 导出系统的逻辑模型
    * 书写软件需求规格说明书(作用：项目合同、设计依据、测试基础)
    * 修正系统开发计划

##### 结构化分析
    * 结构化分析方法就是面向数据流自顶向下
      逐步求精进行需求分析的方法。
    * 实质上是一种创建模型的活动

##### 实体联系图（ER图，P63）
##### 状态转换图（P65）
##### 验证软件需求
    1. 一致性
    2. 完整性
    3. 现实性
    4. 有效性

---

### 第五章
    总体设计过程通常由两个阶段组成：
        * 系统设计阶段，确定系统的具体实现方案；
        * 结构设计阶段，确定软件结构。

* 总体设计的任务：
    * “概括地说，系统应该如何实现？”
    * 系统划分:即确定组成系统的程序、文件、数据库、人工过程和文档等
    * 设计软件的结构：即确定每个程序是由哪些模块组成，以及这些模块相互间的关系。
    * 设计数据库
    * 制定测试计划

* 总体设计的原理：
    * 模块化
    * 抽象：抽象就是抽出事物的本质特性而暂不考虑它们的细节
    * 自顶向下逐步求精：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑
    * 信息隐藏:
        应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。
    * 局部化:把一些关系密切的软件元素物理地放得彼此靠近
    * 模块独立:低耦合，高内聚
* 耦合（由高到低）：
    * 内容耦合
    * 共用耦合：两个或多个模块通过一个公共数据环境相互作用时、
    * 控制耦合
    * 印记（特征）耦合：当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时。
    * 数据耦合:系统中至少必须存在这种耦合。

    ** 尽量使用数据耦合，少用控制耦合和特征耦合，限制公用耦合的范围，完全不用内容耦合。**

* 内聚
    * 低内聚
        * 偶然内聚：一个模块完成一组任务，任务间关系很松散。
        * 逻辑内聚：若干个逻辑功能类似的任务组成一个模块。
        * 时间内聚：若干个任务必须在同一时间内执行，如初始化工作
    * 中内聚
        * 过程内聚：模块内的处理元素是相关的，且必须以特定的次序执行
        * 通信内聚：模块中所有的元素都使用同一个输入数据，和/或产生同一个输出数据
    * 高内聚
        * 顺序内聚：模块中所有处理元素和同一个功能密切相关，且这些处理必须顺序执行
        * 功能内聚：所有处理元素属于一个整体，完成一个单一的功能。

##### 启发规则
    1. 改进软件结构提高模块独立性
    2. 模块规模应该适中（过小的模块不值得单独存在）
    3. 深度、宽度、扇出和扇入都应适当
        1. 深度：软件结构中控制的层数，层数过多可以考虑是否适当合并。
        2. 宽度：同一层次上的模块总数的最大值，宽度越大系统越复杂。
        3. 扇出：一个模块直接控制的模块数目，通常扇出是3-4（上限5-9）
        4. 扇入：表明有都少个上级模块直接调用它，
           扇入越大共享该模块的上级数目越多。（不能违背模块独立性）
    4. 模块的作用域应该在控制域之内
    5. 力争降低模块接口的复杂程度
    6. 设计单入口单出口的模块
    7. 模块功能应该可以预测

---

### 第六章

---

##### 详细设计

* 任务
    确定每个模块的处理过程（数据结构算法）
* 结构化程序设计
    * 以使程序结构清晰、易读易理解为目的编写程序
    * 自顶向下逐步求精；
    * 结构化定理：任何程序都可以由“顺序”、“选择”和“循环”三种基本结构（单入 口、单出口）实现；
    * 有限制地使用GOTO语句
* 程序流程图
    * 缺点：
        1. 本质上不是逐步求精的好工具，诱使程序员过早地考虑程序的控制流程，而不去考虑城区的全局结构
        2. 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移数据
        3. 程序流程图不易表示控制结构
* 盒图（N-S图）
    * 特点：
        1. 功能域明确，可以从盒图上一眼就看出来
        2. 不可能任意转移控制
        3. 很容易确定局部和全程数据的作用域
        4. 很容易表现嵌套关系，也可以表示模块的层次结构。
* PAD图（问题分析图）
    * 优点
        1. 使用表示结构化控制结构的PAD符号所设计出来的程序边是结构化程序
        2. PAD图所描绘的程序结构十分清晰
        3. PAD图表现程序逻辑，易读易懂易记
        4. 容易将PAD图转换成高级语言程序
        5. 既可以用于表示程序逻辑，也可用于描绘数据结构
        6. PAD图的符号支持自顶向下、逐步求精方法的使用
* 判定表（P128）
    ** 判定表可以清晰地表示复杂的条件组合与应做的动作之间的对应关系

###### 例.P141/3
---
### 第七章
    通常把编码和测试统称为实现

##### 编码风格

    编码风格的作用就是使代码容易读
    风格良好的代码更容易阅读和理解，错误更少

    ---

    1. 使用一致和有意义的标识符名
    2. 用缩进显示程序结构
    3. 程序的注释（序言性注释和功能性注释）
    4. 不要为了节省空间而把多个语句写在同一行
    5. 利用括号使逻辑表达式或算术表达式的运算次序清晰直观
    6. 避免大量使用循环嵌套和条件嵌套
    7. 对所有输入数据都进行校验，以保证每个数据的有效性
    8. 检查重要的输入项组合的合法性
    9. 输入一批数据时，使用输入结束指示符，不要要求用户说明输入项数
    10.尽量不要进行浮点数的相等比较
    11.清晰的代码，而非最巧妙的代码
    

##### 测试目的

    在软件投入生产性运行之前，尽可能多地发现软件中的错误。
    调试的目的是诊断并改正错误。

* 测试的目标
    * 测试是为了发现程序中的错误而执行程序的过程。        
    * 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。
    * 成功的测试是发现了至今为止尚未发现的错误的测试。

* 测试的准则
    * 测试只能查找出程序中的错误，不能证明程序中没有错误。
    * 应该在测试开始之前就制定出测试计划。
    * Pareto原理：80%的错误很可能是20%的模块造成的。
    * 从“小规模”测试逐步到“大规模”测试。 
    * 穷举测试是不可能的。
    * 为了达到最佳的测试效果，应该由独立的第三方从事测试工作

##### 测试方法
* 黑盒测试
    * 已经知道了产品应该具有的功能，通过测试来检验是否每个功能都能正常使用
    * 又称功能测试或数据驱动测试
* 白盒测试
    * 知道产品的内部工作过程，可以通过测试来检验产品内部动作是否按照规格说明书的规定正常进行
    * 又称结构测试或逻辑驱动测试
* 测试步骤
    * 模块测试（单元测试）
        * 在这个测试步骤中所发现的往往是**编码和详细设计**的错误 
    * 子系统测试
        * 经过单元测试的模块放在一起形成一个子系统来测试
        * 着重测试模块的接口
    * 系统测试
        * 经过测试的子系统装配成一个完整的系统来测试
        * 发现的往往是软件设计中的错误
    * 验收测试（确认测试）
        * 它的目标是验证软件的有效性（如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的）
        * 目的是验证系统确实能够满足用户的需要
        * 用户积极参与，可能主要使用实际数据进行测试
        * 发现的往往是系统需求说明书中的错误
        * Alpha测试：用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。
        * Beta测试：用户在一个或多个客户场所进行，开发者通常不在Beta测试现场。
    * 平行运行
        * 同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果
    
##### 集成测试
* 非渐增式测试
    * 先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。
    * 先进行单元测试，再进行集成测试
    * 必须写存根和驱动，在模块测试完成后抛弃
    * 缺点：没有错误隔离手段，主要设计错误发现迟

* 渐增式测试（集成测试时普遍采用）
    * 将单元测试与集成测试结合在一起，把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。
    * 自顶向下（Top-Down）集成
        * 优点：错误隔离，较早发现主要设计错误；不需要测试驱动程序。
        * 缺点：需要存根程序，可复用模块得不到充分测试
    * 自底往上（Bottom-Up）集成
        * 优点：错误隔离,可复用模块得到充分测试
        * 缺点：主要设计错误发现迟
    * 三明治式（Sandwich）集成
        * 错误隔离，较早发现主要设计错误，可复用模块得到充分测试
        * 较上层的模块使用自顶向下的方法，较下层的使用自底向上的方法。
* 回归测试
    重新执行已经做过的测试的某个子集

##### 白盒测试技术
    以程序内部的逻辑结构为基础的设计测试用例的技术

* 设计测试方案的基本目标是，确定一组最可能发现某个错误或某类错误的测试数据
* 逻辑覆盖
    * 源程序语句检测
        * 语句覆盖（很弱的逻辑覆盖标准）
            * 选择足够多的测试数据，使被测试程序中每个语句至少被执行一次
        * 判定覆盖（分支覆盖）
            * 不仅每个语句必须至少执行一次，而且每个判定的每种更可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次
            * 比语句覆盖强，但仍然不高
        * 条件覆盖 
            * 不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果
        * 判定／条件覆盖
            * 选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果
        * 条件组合覆盖 
            * 要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次
    * 程序路径覆盖
        * 点覆盖
            如果连通图G的子图G'是连通的，而且包含G的所有节点，则称G'是G的点覆盖 
        * 边覆盖 
            如果连通图G的子图G'是连通的，而且包含G的所有边，则称G'是G的边覆盖
        * 路径覆盖
            选取足够多的测试数据，使程序的每条可能路径都至少执行一次（如果有环，则要求每个环至少经过一次）

##### 黑盒测试技术
    黑盒测试着重测试软件功能。
    力图发现下述类型错误：
    1. 功能不正确或遗漏了功能
    2. 界面错误
    3. 数据结构错误或外部数据库访问错误
    4. 性能错误
    5. 初始化和终止错误

* 等价划分
    * 把程序的输入域划分成若干个数据类，据此导出测试用例。每类中的一个典型值在测试中的作用与这一类中所有其他值的作用相同。据此导出测试用例。
    * 设计测试用例
        1. 设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止；
        2. 设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止。

* 边界值分析
    * 着重测试输入等价类和输出等价类的边界值，选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值

##### 调试
* 调试的基本任务   
    * 确定程序中可疑错误的确切性质和位置。
    * 对程序进行修改，排除这个错误。

* 调试的途径
    * 蛮干法
        可能是寻找软件错误原因的最低效的方法，仅当所有其他方法都失败了的情况才使用。
    * 回溯法
        从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码。
    * 原因排除法
        对分查找法、归纳法和演绎法

##### 软件可靠性
    软件可靠性是程序在给定的时间间隔内，
    按照规格说明书的规定成功地运行的概率。

### 第八章
    所谓软件维护就是在软件已经交付使用之后，
    为了改正错误或满足新的需要而修改软件的过程。
    保证软件在一个相当长的时期（60%以上）能够正常运行。
* 维护类型
    *改正性维护
        *诊断和改正错误的过程。17%～21%
    * 适应性维护
        * 为了适应环境的变化进行的修改软件的活动。 18%～25%
    * 完善性维护
        * 增加新功能或修改已有功能。 50%～66%
    * 预防性维护
        * 为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件。4%左右

* 维护过程
    * 维护过程本质上是修改和压缩了的软件定义和开发过程
    * 维护组织
    * 维护报告
    * 维护的事件流
    * 保存维护记录
    * 评价维护活动

* 可维护性
    * 维护人员理解、改正、改动或改进这个软件的难易程度。
    * 提高可维护性是支配软件工程方法学所有步骤的**关键目标**。
    * 决定软件可维护性的因素
        1）可理解性
        2）可测试性
        3）可修改性
        4）可移植性
        5）可重用性

维护是软件生命周期的最后一个阶段，也是持续时间最长，代价最大的一个阶段。

软件工程学的**主要目的**：提高软件的可维护性，降低维护的代价。

---

### 第九/十/十一章

##### 面向对象
* 四要素
    * 对象：客观世界是由各种对象组成。面向对象的软件系统是由对象组成的
    * 类：对象组成对象类。类是具有相同属性和行为的对象的集合。每个对象类定义了一组数据和一组方法。
    * 继承：按照子类(派生类)与父类(基类)的关系，对象类组成一个层次结构的系统(类等级)。子类继承(inheritance)父类的数据和方法
    * 消息：对象彼此之间仅能通过传递消息(Message)互相联系
`面向对象 = 对象 + 类 + 继承 + 消息通信`

#### 概念
    * 对象：封装了数据结构及可以施加在这些数据结构上的操作（服务或方法）的封装体。
    * 类：具有相同数据和相同操作的一组相似对象的集合
    * 消息：要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明。
    * 方法：对象所能执行的操作，也就是类中所定义的服务。（如C++的成员函数）
    * 属性：类中所定义的数据（如C++的数据成员）
    * 封装：表示对象状态的数据和实现操作的代码与局部数据，
      都被封装在黑盒子里面，不能从外面直接访问或修改这些数据和代码。
    * 继承：是子类自动地共享基类中定义的数据和方法的机制。
    * 多态性：同一方法，不同的子类有不同的实现。
    * 函数重载：是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字。

##### 面向对象分析
    1. 寻找类－&－对象；
    2. 识别结构；
    3. 识别主题；
    4. 定义属性；
    5. 建立动态模型；
    6. 建立功能模型；
    7. 定义服务

##### 对象模型
    表示静态、结构化的系统的数据性质，是对模拟客观世界实体的对象以及对象彼此之间的关系的映射
* 类图
    * 描述类以及类与类之间的静态关系，是一种静态模型
    * 关联、聚集、泛化（继承）

##### 动态模型
    * 顺序图（P250）
    * 状态图（P252）

##### 功能模型
    * 用例图（扩展、包含）

##### 面向对象设计
    可以把面向对象细分为 系统设计 和 对象设计
    尽管分析和设计的定义有明显区别，但是在实际的软件开发过程中二者的界限是模糊的。

* 系统设计
    *　确定实现系统的策略和目标系统的高层结构;
* 对象设计
    * 确定解空间中的类、关联、接口形式及实现服务的算法。

* 面向对象设计准则
    * 模块化
    * 抽象
    * 信息隐藏
    * 弱耦合
        * 交互耦合
            * 对象之间的耦合通过消息连接来实现
            * 应使交互耦合尽量松散————降低消息连接的复杂程度，减少对象发送、接受的消息数
        * 继承耦合
            * 一般化类与特殊类之间的耦合的一种形式
            * 应该提高继承耦合
    * 强内聚
        * 服务内聚：一个服务应该完成一个且仅完成一个功能
        * 类内聚
        * 一般-特殊内聚
    * 可重用

一般来说，紧密的继承耦合和高度的一般-特殊内聚是一致的。

##### 启发规则
* 设计结果应该清晰易懂
* 一般-特殊结构的深度适当
    * 一般在中等规模（大约包含100个类）的系统中，类的等级层次数应该保持在（5-9）
* 设计简单的类
    * 应该尽量设计小而简单的类

##### 软件成分的重用
* 代码重用：
    源代码剪贴、源代码包含、继承
* 设计结果重用：
    重用某个软件系统的设计模型
* 分析结果重用：
    重用某个系统的分析模型

##### 类构件的重用
    重用有两方面的含义： 一是尽量使用已有的类，
    二是如果确实需要创建新类，则在设计这些新类的协议时，
    应该考虑将来的可重复使用性。
    

* 类构件的重用方式

1. 实例重用
    1. 按照需要创建类的实例   
    2. 用几个简单的对象作为类的成员创建出一个更复杂的类。
2. 继承重用
    1. 为提高继承重用的效果，关键是设计一个合理的、具有一定深度的类构件继承层次结构。
3. 多态重用
    1. 多态性使对象的接口更加一般化(基类与派生类的接口相同)，降低了消息连接的复杂程度。
    2. 转换接口：类构件在重用时都必须重新定义的服务的集合。
    3. 扩充接口：如果在派生类中没有给出扩充接口的新算法，则将继承父类中的算法。


##### 大题重点：
    1. 分层数据流图
    2. 盒图、判定表
    3. 测试覆盖、等价类划分
    4. ER图、顺序图、状态图
    5. 用例图、类图







