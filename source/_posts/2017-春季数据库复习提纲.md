---
title: 2017-春季数据库复习提纲
date: 2017-06-05 14:56:09
tags:
categories: "春季复习提纲"
---
# 前言
> 没有前言。不想说了。没重点，我不说话。

<!--more-->

# 题型
>选择20 填空10 判断10 大题50

# 第五章·规范化设计

### 关系模式的冗余和异常问题

* 数据冗余是指同一个数据在系统中多次重复出现。
* 操作异常
    - 修改异常
    - 插入异常
    - 删除异常

---

### 函数依赖

* FD
    - 设有关系模式R(U)，X和Y是属性集U的子集，函数依赖（FD)是形为X->Y的一个命题。（X函数决定Y、Y函数依赖于X）
* FD的逻辑蕴含
    - 设F是在关系模式R(U)上成立的函数依赖集，X和Y是属性集U的子集，如果从F导出X->Y也在R(U)上成立，那么称F逻辑蕴含X->Y,记为F |= X->Y
* 闭包
    - 设F是函数依赖集，被F逻辑蕴含的函数依赖全体构成的集合称为函数依赖集F的闭包，记为F+
    - F+ = {X->Y | F|=X->Y}

---

### FD的推理规则

* 设U是关系模式R的属性集，F是R上成立的只涉及U中属性的函数依赖集
    - A1(自反性)：若Y属于X属于U，则X->Y在R上成立
    - A2(增广性)：若X->Y在R上成立，且Z属于U，则XZ->YZ在R上成立
    - A3(传递性)：若X->Y和Y->Z在R上成立，则X->Z在R上成立
* 如果X->Y是从F用推理规则导出，那么X->Y在F+中
* 对于FD  X->Y，如果Y属于X，那么称X->Y是一个 *平凡的FD*(AB->A)，否则称为 *非平凡的FD*(A->B)
* 完整性
    - F+中的FD都能从F集使用推理规则集导出。
* 正确性
    - 从FD集F使用推理规则集推出的FD并在F+中

* *正确性*保证了推出的所有FD是正确的，完备性保证了可以推出所有被蕴含的FD。从而保证了推导的有效性和可靠性。

---
* 
### FD和关键码的联系
* 设关系模式R的属性集是U，X是U的一个子集，如果X->U在R上成立，那么称X是R的一个 *超键*（含有多余属性）。
* 如果X->U在R上成立，但对于X的任一真子集X1，都有X1->U不成立，那么称X是R上的一个 *候选键*（不含有多余属性）。

---

### 属性集的闭包
* 设F是属性集U上的FD集，X是U的子集，那么（相对于F）属性集X的的闭包用X+表示，它是一个从F集使用FD推理规则退出的所有满足X->A的属性A的集合
    - X+ = {属性A|X->A在F+中}
* X->Y能用FD推理规则推出的充分必要条件是Y属于X+

---

### FD集的最小依赖集

* 如果关系模式R(U)上的两个函数依赖集F和G，有F+ = G+，则称F和G是 *等价的函数依赖集*
* 最小依赖集条件：
    - F+min = F+;
    - 每个FD的右边都是单属性
    - Fmin中没有冗余的FD
    - 每个FD的左边没有冗余属性

---

### 无损分解
>设R是一个关系模式，F是R上的一个FD集。R分解成数据库模式，如果对R中满足F的每一个关系r投影、联接后仍然能恢复成r，则称为无损分解，否则为损失分解。

* 无损分解的测试方法
    - 画表格
    - P113
    - 无损分解的充分必要条件
        + (R1 ∩ R2)->(R1 - R2) 或 (R1 ∩ R2)->(R2 - R1)
    
* 保持函数依赖的分解
    - 设F是属性集U上的FD集,Z是U的子集，F在Z上投影用πz(F)表示，定义为：
        + πz(F) = {X->Y | X->Y ∈ F+,且XY包含于Z}

---

### 第一范式

* 如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是第一范式模式
* 满足1NF的关系称为规范化的关系，否则称为非规范化的关系。
* 1NF是关系模式应具备的最起码的条件

### 第二范式

* 对FD W->A如果存在X存在于W，有X->A成立，那么称W->A是局部依赖，否则称W->A是完全依赖
* 如果A是关系模式R的候选键中的属性，那么称A是R的主属性；否则称A是R的非主属性。
* 如果关系模式R是1NF，且每个非主属性 *完全函数依赖*于候选键，那么R是第二范式（2NF)。

### 第三范式
* 如果X->Y,Y->A,且Y不能推出X，和A∉Y，那么称X->A是传递依赖。
* 如果关系模式R是1NF，且每个 *非主属性* 都 *不传递依赖*于R的候选键，那么称R是第三范式（3NF)的模式。
* 如果数据库模式中每个关系模式都是3NF，则称其为3NF的数据库模式。

* 分解成3NF模式集的方法
    - 对于关系模式R和R上成立的FD集F，求出F的最小依赖集，然后把最小依赖集中左部左部相同的FD用合并性合并起来。
    - 对最小依赖集中每个FD X->Y去构成一个模式XY
    - 在构成的模式集中，如果每个模式都不包含R的候选键，那么把候选键作为一个模式放入模式集中。

### BCNF
* 如果关系模式R是1NF，且每个 *属性* 都不传递依赖于R的候选键，那么称R是BCNF的模式。
* 如果数据库模式中每个关系模式都是BCNF，则称为BCNF的数据库模式。

* 分解成BCNF模式集的方法
    - 如果p中有一个关系模式Ri相对于πRi(F)不是BCNF,则此时，Ri中存在一个非平凡FD X->Y，有X不包含超键，此时把Ri分解成XY和Ri-Y两个模式。重复上述过程。

### 多值依赖(MVD)
* 设U是关系模式R的属性集，X和Y是U的子集，Z=R-X-Y,小写的xyz表示属性集XYZ的值。对于R的关系r,在r中存在元组（x,y1,z1)和（x,y2,z2)时，也就(x,y1,z1),(x,y2,z2)那么称多值依赖。X->->Y在模式R上成立。
* 对于属性集U上的MVD X->->Y，如果Y包含于X，或者XY = U，那么称X->->Y是平凡的MVD,否则称为非平凡的多值依赖。

### 第四范式
* 设D是关系模式R上成立的FD和MVD集合，如果D中每个费平凡的MVD X->->Y的左部X都是R的超键，那么称R是4NF的模式

### 第五范式
* 如果关系模式R的每个JD均由R的候选键蕴含，那么称R是5NF模式。

# 第七章·数据库设计
<!-- 
### 软件生存期
* 规划阶段
    - 确定开发的总目标，给出计划开发的软件系统的功能、性能、可靠性以及接口等方面的设想。
* 需求分析阶段
    - 了解度数据的加工要求，确定系统的功能域边界。
    - 结果：提供一个可作为设计基础的系统规格说明书，包括对软硬件环境的需求和一整套完整的数据流程图
* 设计阶段
    - 把需求分析阶段所确定的功能细化，主要工作是设计模块结构图和系统的数据结构。对每个模块内部设计详细的流程。
* 程序编制阶段
    - 对某一种或几种特定的程序设计语言表达上一阶段确定的各模块控制流程。程序编制时应遵循结构化程序设计方法。
* 调试阶段
    - 对已经编制好的程序进行单元调试（分调）、整体调试（联调）和系统测试（验收）
* 运行维护阶段
    - 这是整个生存期中时间最长的阶段，其工作重点是将系统付诸实用，同时解决开发过程的遗留问题，改正错误并进行功能扩充和性能改善。 -->

### 数据库系统生存期

* 七个阶段
    - 规划
        + 进行监理数据库的必要性及可行性分析，确定数据库系统在组织中和信息系统中的地位，以及各个数据库之间的关系。
    - 需求分析
        + 收集用户需求；编写需求分析报告（数据流图DFD和数据字典DD）
    - 概念设计
        + 设计概念模型（ER模型）
    - 逻辑设计
        + 把ER模型转换成关系模型
    - 物理设计
        + 设计DB物理结构（存储结构和存储方法）
    - 实现
    - 运行维护

# 第八章·数据库管理

### 事务的定义

* 事务
    - 是构成单一逻辑工作单元的操作集合。不论发生何种情况，DBS必须保证事务能正确、完整地执行。
    - 在程序中事务以BEGIN TRANSACTION语句开始，以COMMIT语句或ROLLBACK语句结束。
* COMMIT语句 
    - 表示事务执行成功地结束（提交），该事务对数据库的所有更新都已交付实施（写入磁盘）

* ROLLBACK
    - 语句表示事务执行不成功地结束（回退），此时告诉系统，已发生错误，数据库可能处在不正确的状态，该事务对数据库的所有更新必须被撤销，数据库应恢复该事务到初始状态。

### 事务的ACID性质

* 原子性
    - 一个事务对数据库的所有操作，是一个不可分割的工作单元
* 一致性
    - 一个事务独立执行的结果，应保持数据库的一致性
* 隔离性
    - 多个事务并发执行时，系统应保证与这些事务先后单独执行时的结果一样
* 持久性
    - 一个事务一旦完成全部操作后，它对数据库的所有更新应永久地反应在数据库中，不会丢失。

### 数据库的恢复

* 系统能把数据库从被破坏、不正确的状态，恢复到最近一个正确的状态，DBMS的这种能力称为 *数据库的可恢复性*(Recovery)

* 恢复的基本原则：数据库重复存储
* 恢复的实现方法
    - 转储和建立日志
        + 周期地对整个数据库进行拷贝，转储到另一个磁盘或磁带一类的存储介质中。
        + 建立日志数据库。
    - 一旦发生数据库故障
        + 如果数据库已被损坏，就必须装入最近一次拷贝的数据库备份到新的磁盘。
        + 如果数据库未被破坏，但某些数据不可靠，则通过日志库执行撤销

### 故障的类型

* 事务故障
    - 可以预期的事务故障，在程序中可以预先估计到的错误，如存款余额透支。
    - 非预期的事务故障，如运算溢出，数据错误。
* 系统故障
    - 引起系统停止运行环随之要求重新启动的事件。如硬件故障、软件错误或掉电等几种情况。
* 介质故障
    - 发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。
* 系统故障通常称为软故障，介质故障通常称为硬故障。

### 检查点机制

* DBMS定时设置检查点，在检查点时刻才真正把对DB的修改写到磁盘，并在日志文件写入一条检查点记录。
* 当DB需要回复时只有那些在检查点后面的还在执行的事务需要恢复。

* 检查点方法的恢复算法
    - 根据日志文件建立事务重做队列和事务撤销队列
        + 从头扫描日志文件（正向扫描）
    - 对重做队列的事务金乌REDO处理，对撤销队列的事务进行UNDO处理
        + REDO
            * 正向扫描日志文件，根据重做队列的记录对每一个重做事务重新实施对数据库的更新操作
        + UNDO
            * 反向扫描日志文件，根据撤销队列的记录对每一个撤销事务的更新操作执行逆操作（对插入操作执行删除操作，对删除操作执行cherub操作，对修改操作则用修改前的值代替修改后的值）

### 并发操作带来的三个问题
* 丢失更新问题
* 读脏数据问题
* 不一致分析问题

### 封锁机制
* 排他型封锁
    - X锁
        + 如果事务T对某个数据实现X锁，那么其他事务T'要等T接触X锁以后，才能对这个数据进行封锁。
        + PX协议
            * 任何企图更新记录R的事务必须先执行“XFIND R"的操作，已获得对R的X锁，才能读或写记录R；如果未获准X锁，那么这个事务进入等待状态，一直到获准X锁，事务才能继续做下去。
        + PXC协议
            * X锁的解锁操作应该合并到事务的结束(COMMIT或RILLBACK)操作中。
* 共享型封锁
    - S锁
        + 如果事务T对某数据加上S锁后，仍允许其他事务再对该数据加S锁，但在对该数据的所有S锁都解锁之前决不允许任何事务对该数据加X锁。
        + PS协议
            * 任何要更新记录R的事务必须先执行SFIND R操作，已获得对R的S锁。若要更新记录R必须用UPDX R操作，这个操作首先把S锁升级为X锁，若成功则更新记录
        + PSC协议
            * S锁的解锁操作应该合并到事务的结束操作

### 活锁、饿死和死锁
* 活锁
    - 系统可能使某个事务永远处于等待状态，得不到封锁的机会
    - 解决活锁的一种简单方式是采用 *先来先服务*策略。
* 饿死
    - 有可能存在一个事务序列，其中每个事务都申请对某数据加S锁，且每个事务在授权加锁后一小段时间内释放封锁，此时若另有一个事务T1欲在该数据项上加X锁，则永远轮不到封锁的机会
    - 避免方法：当事务T2申请对数据项Q加S锁时，条件：
        + 不存在在数据线Q上持有X锁的其他事物
        + 不存在等待对数据项Q加锁，且先于T2申请加锁的事务
* 死锁
    - 系统中有两个或两个以上的事务都处于等待状态，并且每个事务都在等待其中另一个事务解除封锁。

### 并发调度的可串行化
* 事务的调度、串行调度和并发调度
    - 事务的执行次序称为"调度"
    - 如果多个事务依次执行，则称为事务的 *串行调度*
    - 如果利用分时的方法，同时处理多个事务，则称为事务的 *并发调度*

* 可串行化概念
    - 每个事务中，语句的先后顺序在各种调度中始终保持一致。在这个前提下，如果一个并发调度的执行结果与某一串行调度的执行结果等价，则称其为"可串行化调度"。
* 两段封锁法
    - 两段封锁协议
        + 在对任何一个数据进行写操作之前，事务必须获得对该数据的封锁
        + 在释放一个封锁之后，事务不再获得任何其他封锁
    - 如果所有的事务都遵循"两段封锁协议"，则所有可能的并发调度都是可串行化的。
    - 两段式封锁是可串行化的充分条件，但不是必要条件。
    - 两段封锁协议仍有可能导致死锁的发生，而且可能会增多。

### SQL中事务的存取模式和隔离级别
* 事务的存取模式
    - READ ONLY(只读型)
    - READ WRITE(读写型)
* 事务的隔离级别
    - SERIALIZABLE(可串行化)
    - REPEATABLE READ(可重复读)
    - READ COMMITTED(读提交数据)
    - READ UNCOMMITTED(可以读未提交数据)

### 数据库的完整性
>数据库中完整性一词是指数据的正确性、有效性和相容性

* 完整性子系统的主要功能
    - 监督事务的执行，并测试是否违反完整性规则
    - 若有违反现象，则采取恰当的操作，如拒绝操作，报告违反情况，改正错误等方法来处理
* 完整性规则的组成
    - 什么时候使用规则进行检查（触发条件）
    - 要检查什么样的错误（约束条件/谓词）
    - 如果查出错误应该怎么办（ELSE子句）
    
### SQL中的完整性约束
* 域约束
* 基本表约束
    - 候选键定义
        + UNIQUE()
        + PRIMAY KEY()
    - 外键定义
    - 检查约束
        + CHECK()
* 断言
    - CREATE ASSERTION<断言名>CHECK(<条件>)

### SQL3的触发器（P190)

```sql
    CREATE TRIGGER TRIG1
    AFTER UPDATE OF PRICE ON SPJ
    REFERENCING
        OLD AS OLDTUPLE
        NEW AS NEWTUPLE
    WHEN (OLDTUPLE.PRICE > NEWTUPLE.PRICE)
        UPDATE SPJ
        SET PRICE = OLDTUPLE.PRICE
        WHERE SNO = NEWTUPLE.SNO AND PNO.NEWTUPLE.PNO JNO = NEWTUPLE.JNO
    FOR EACH ROW;
```

* 第1行，触发器名字TRIG1
* 第2行，触发事件，即对SPJ的PRICW值修改后激活触发器
* 第3-5行，行为触发器的条件和动作部分设置必要的元组变量OLDTUPLE和NEWTUPLE分别为修改前、后的元组变量
* 第6行，触发器的条件
* 第7-9行，触发器的动作
* 第10行，表示触发器对每一个修改的元组都要检查一次。

* 触发器的撤销语句
```sql
    DROP TRIGGER TRIG1;
```


### 数据库的安全性
* 数据库的安全性是指保护数据库，防止不合法的使用，一面数据的泄密、更改或破坏
* 数据库的安全性级别
    - 环境级
    - 职员级
    - OS级
    - 网络级
    - DBS级
* 权限
    - 访问数据的权限
        + 读
        + 插入
        + 修改
        + 删除
    - 修改数据库结构的权限
        + 索引
        + 资源
        + 修改
        + 撤销
* SQL中的安全性机制
    - 视图
    - SQL 2中的用户权限及其操作
        + 用户权限
            * SELECT
            * INSERT
            * DELETE
            * UPDATE
            * REFERENCES
            * USAGE
        + 授权语句
            * GRANT<权限表>ON<数据库元素>TO<用户名表>[WITH GRANT OPTION]
            * [WITH GRANT OPTION]表示获得权限的用户可以获得传递权限
        + 回收语句
            * REVOKE<权限表> ON <数据库元素> FROM<用户名表>[RESTRICT|CASCADE]
            * CASCADE表示回收权限时引起连锁回收
    - 数据加密
    - 自然环境的安全性

# 第九周·分布式数据库系统

### DDBS·分布式数据库系统
*　一个分布式系统使用通信网络连接起来的结点（场地）的集合，每个结点都是拥有集中式数据库的计算机系统。
*　表面上看，分布式数据库的数据分散在各个场地上，但这些数据在逻辑上都是一个整体，如同一个集中式数据库。
*　分布式数据库有 *局部数据库*和*全局数据库*，这是它"逻辑整体性"的特点。
*　DDB是计算机网络环境中个场地上数据库的逻辑集合
*　DDBMS是DDBS中的一组软件，负责管理分布环境下逻辑继承数据的存取、一致性和完备性。

### DDBS的特点

* 物理分布性
* 逻辑整体性
* 场地自治性
* 场地指尖的协作性

# 第十章·对象关系数据库

* 嵌套关系
    - 允许关系的属性值又可以是一个关系，而且可以出现多次嵌套
* 复合对象
    - 关系中的属性类型可以是基本数据类型，也可以是结构类型（元组类型）或集合类型
    （关系类型）
* 引用类型
    - 引用计数解决类型定义中的递归问题。
    - 相当于程序设计中指针的概念，在面向对象技术中称为*对象标识*。

### 复合类型（P221）
* 行类型
    - 不同类型元素的有序集合
* 数组类型
    - 相同类型元素的有序集合
* 列表类型
    - 相同类型元素的有序集合，允许重复的元素
* 包类型
    - 相同类型元素的无序集合，允许重复元素
* 集合类型
    - 相同类型元素的无序集合，不允许重复元素

### ORDB的定义(P222)
### 继承性的定义(P223)

*    类
```sql
CREATE TYPE PERSON(NAME MYSTRING,SOCIAL_NUMBER INTEGER);
CREATE TYPE STUDENT(DEGREE MYSTRING,DEPARTMENT MYSTRING ) UNDER PERSON;
```
* 表
    - 超标中每个元组最多可以与每个子表中的一个元组对应
    - 子表中的每个元组在超表中恰有一个元组对应，并在继承的属性上有相同的值

### ORDB 查询语言(P226)
* 允许用于计算关系的表达式出现在任何关系名可以出现的地方
* 规定应为每个基本表设置一个元组标量，然后才可以引用"FROM UNIVERSITY AS U"
* 都能过路径中某个属性值为集合时，就应该定义一个元组变量

# 第十一章·面向对象数据库

* 面向对象数据库系统(OODBS)是一个数据库系统，同时是一个面向对象系统，是针对面向对象程序设计语言的持久性对象存储管理而设计的