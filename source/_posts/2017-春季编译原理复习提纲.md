---
title: 2017-春季编译原理复习提纲
date: 2017-06-01 16:32:05
updated: 2017-06-01 16:32:05
tags:
categories: "春季复习提纲"
---
# 前言
>编译没有画重点T T不知道考什么，求重点

<!--more-->

# 第一章·引论

### 什么是编译程序
>编译程序是现代计算机系统的基本组成部分之一，而且多数计算机系统都配有不止一种高级语言的编译程序，对有些高级语言甚至配饰了几个不同性能的编译程序。

>一个编译程序就是一个语言翻译程序。它把一种高级语言（称作源语言）书写的程序翻译成另一种低级语言（称作目标语言）的等价的程序。


### 编译程序的过程

* 前端：主要依赖于源语言而与目标机器无关，通常包括：
    - 词法分析
    - 语法分析
    - 语义分析
    - 中间代码生成
    - 某些优化工作也可以在前端完成，还包括与 *前端每个阶段相关* 的出错处理工作个符号表管理工作
* 代码优化
* 后端：依赖于目标机器而一般不依赖于源语言，只与中间代码有关的那些阶段的工作，还包括相关出错处理和符号表操作：
    - 目标代码生成
    - 以及相关出错处理和符号表操作


* 一个编译过程可由一遍、两遍或多遍完成
    - “遍”也称为“趟”是对源程序或其等价的中间语言程序从头到尾扫描并完成规定任务的过程。
    - 每一遍扫描可由完成上述一个阶段或多个阶段的工作
    - 对于多遍的编译程序，第一遍的输入是用户书写的源程序，最后一遍的输出是目标程序。
    - PL/0语言是单遍的。

---

### 解释程序

* 编译程序是一个语言处理程序，它把一个高级语言程序翻译成某个机器的汇编语言程序或二进制代码程序，这个二级制代码程序在机器上运行以生成结果。
* 解释程序接受某个语言的程序，并立即运行这个源程序
    - 它的工作模式是一个个的获取、分析并执行源程序语句,一旦第一个语句分析结束，源程序便开始运行并生成结果
    - 它特别适合程序员以交互方式工作的情况

---

### PL/0编译程序
* PL/0语言编译系统由编译程序和解释程序两部分组成，分别称为PL/0编译程序和类P-code解释程序。
* PL/0编译程序采用 *单遍扫描方式*的编译过程，由词法分析程序、语法语义分析程序以及代码生成程序3个独立的过程完成。

# 第二章·文法和语言

### 文法和语言的形式定义

* 规则
    - 也称为 *重写规则*、 *产生式*、 *生成式*
* G(V_N,V_T,P,S)
    - V_N：非终结符集
    - V_t：终结符集
    - P：规则集合
    - S：识别符或者开始符，是一个非终结符，至少要在一条规则中作为左部出现
    - V_N和V_T不含公共的元素
    - 通常用V表示V_N U V_T，V称为文法G的字母表或者字汇表

* 直接推导和直接规约（P22-23,定义2.2，2.3,2.4)
* +推导：推导长度n>=1;\*推导：推导长度n>=0
* 设G[S]是一个文法，如果符号串x是从识别符号推导出来的，则称x是文法G[S]的 *句型*，若x仅由终结符号组成，则称x为G[S]的 *句子*
* 文法描述的语言是该文法一起句子的集合
* 若L(G1) = L(G2)则称 *文法G1和G2是等价的*

* 二义性：同样的表达式存在着两个不同的语法树（同最左/右推导）
---

### 文法的类型

* 0型文法
    - 每一个产生式a->b,a中至少含有一个非终结符
* 1型文法（上下文有关文法）
    - 每一个产生式a->b,均满足 *|b| >= |a|* 仅仅S->ε除外。
* ２型文法（上下文无关文法）
    - 每一个产生式a->b,a是一个非终结符 
* 3型文法（正规文法）
    - 每一个产生式的形式都是 *A->aB* 或者 *A->a*
* 例如（A->B是2不是3)

---

### 上下文无关文法及其语法树

* 最左（最右）推导
    - 在推导的任何一步，都是对a中最左（最右）非终结符使用产生式进行替换
    - 最右推导常被称作 *规范推导*，所得句型称为 *规范句型*或者 *最右句型*

* 二义性
    - 如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是 *二义*的。即某个据此有两个不同的最左（最右）推导。

---

### 句型分析

* 短语
    - 如果有S->aAo,A->（+）b,则称，b是句型abo相对于非终结符A的短语。
    - 如果A->b（直接推出），则称为 *直接短语*
    - 一个右句型的直接短语称为该句的 *句柄*

# 第三章·词法分析

* 正规式 
    - ‘|’ 或
    - ‘.’ 连接
    - ‘\*’ 闭包
    - ‘A->aA|a’ a^*a
    - ‘A->aA|ε’ a^*
    - ‘A→aAb|ab’ a^n b^n
    - ‘A→aAb | aBb；B→dB | d’  a^n d^m b^n

* 有穷自动机
    - 确定的有穷自动机（DFA)
        + 假定DFA有m个状态n个输入符号，那么这个状态图含有m个结点，每个结点最多有n个弧射出，整个图有唯一的初态结点和若干个终态结点。
    - 不确定的有穷自动机（NFA)
        + 一个含有m个状态n个输入符号的NFA，可表示含有m个状态结点，每个结点可射出若干条箭弧与别的结点相连接的状态图。
* NFA转换成等价的DFA
    - 设L为一个由不确定的有穷自动机接受的集合，则存在一个接受L的确定的有穷自动机
    - 子集法(P50)

* 确定的有穷自动机的化简
    - 化简：说明没有多余状态，并且状态中没有两个是互相等价的。
    - 在有穷自动机中，两个状态s和t的等价的条件：
        + 一致性条件：状态s和t必须同时为可接受(终态)或不可接受状态
        + 蔓延性条件：对于所有输入符号，状态s和状态t必须同时为可接受状态或不可接受状态
    - 分割法

* 将NFA转换成正规文法
    - 注意：终态结点需要 ：D->ε


# 第四章·自顶向下语法分析方法

### 分析思想

* FIRST\FOLLOW\SELECT
* SELECT(P71)
    - a是终结符或非终结符，A是非终结符
    - 如果a->ε，则SELECT(A->a) = (FIRST(a) - ε) ∪ FOLLOW(A)
    - 如果a不能推导出ε，则SELECT(A->a) = FIRST(a)
* 上下文无关文法是LL(1)的 *充分必要条件*
    - A->a,A->b满足：SELECT(A->a) ∩ SELECT(A->b) = Ф（空）

---

### LL(1)文法判别

* 不含左公共因子
* 不含左递归
* 当需要选用自顶向下分析技术时，必须判别所给文法是否是LL(1)文法。
* 计算FIRST集、计算FOLLOW集、计算SELECT
* 例题：P72  Q4.5

---

### 某些非LL(1)文法到LL(1)文法的等价变换
* 提取左公共因子（P78)
    - 不含左公共因子是LL(1)文法的必要条件，而不是充分条件

* 消除左递归
    - 直接左递归和间接左递归(P82)

---

### 不确定的自顶向下分析思想
* 当文法不满足LL(1)时，不能用确定的自顶向下分析，但这种情况下可以用不确定的自顶向下分析（带回溯的自顶向下分析）

### LL(1)分析实现
* 表驱动（P92 4.5.2）

# 第五章·自底向上优先分析

>自左向右按句柄归约的过程是自顶向下最右推导的逆过程，而最右推导称为规范推导，因而这一归约过程也称为规范归约。

### 简单文法定义
* 在文法符号集V中，任意两个符号指尖最多只有一种优先关系成立
* 在文法中，任意两个产生式没有相同的右部

### 算符优先
* 算符优先分析法只考虑 *终结符* 之间的优先关系。
* 最左素短语
    - 至少包含一个终结符，并除自身外不包含其他素短语，最左边的速度语称为最左素短语。

### 优先函数
* 当a = b 则f(a) = f(b)
* 当a < b 则f(a) < f(b)
* 当a > b 则f(a) > f(b)

### 算符优先文法的定义
>设有文法G，如果G中没有形如A->...BC...的产生式，其中BC为非终结符，则称G为算符文法，也称OG文法。(没有两个非终结符相邻)



# 第六章·LR分析
* 自底向上分析方法是一种移进-规约过程。
* 当分析的栈顶符号串形成句柄或可规约串时就采取规约动作。

* 一个LR分析器由3部分组成：
    - 总控程序，也可以称为驱动程序。对所有的LR分析器，总控程序都是相同的。
    - 分析表或分析函数。不同的文法分析表将不同。
    - 分析栈，包括文法符号栈和相应的状态栈。

### LR(0)分析
* 可归前缀
    - 包括可规约前缀在内的所有前缀都称为活前缀
* 子前缀

* 拓广文法
    - 在原文法G[S]中新增产生式S->S'，所得的新文法称为G的拓广文法。

---

### LR(0)项目集规范簇的构造
* 构造识别活前缀的NFA（圆点）
* 移进项目
    - A->a·bc,其中a和c属于V，b属于终结符，则在分析时把b移进符号栈
* 待约项目
    - A->a·Bb,其中a,b属于V，B属于非终结符，表明所对应的状态等待着分析完非终结符B所能推出的归约成B
* 归约项目
    - A->a·其中，a属于V，即圆点在最右端的项目，表示归约。
* 接受项目

---

### SLR(1)分析
* SLR(1)是基于容许LR(0)规范族中有冲突的项目集（状态），用 *向前查看一个符号*的办法来进行处理。

* 状态中含有冲突的文法有可能是一个SLR(1)文法

* 移进-归约冲突
    - ·的后面为终结符的为移进
    - 只需要计算归约语句里的非终结符的FOLLOW
* 归约-归约冲突
* I = {X->a·bB,A->y·,B->o·}
    - 其中a,B,y,o为文法符号穿，b为终结符，则只要满足：
    - FOLLOW(A) ∩ FOLLOW(B) = 空
    - FOLLOW(A) ∩ {b} = 空
    - FOLLOW(B) ∩ {b} = 空
    -那么当在I状态下，输入a时：
    - 若a = b移进
    - 若a 属于 FOLLOW(A)用A->y归约
    - 若a 属于 FOLLOW(B)用B->o归约
    - 此外则报错。

* 在SLR中，只有当输入的符号包含在该归约项目左部的非终结符的FOLLOW中，才归约。

# 第七章·语义制导的语义计算

* 属性文法
    - 是一种基本的语义计算模型，适用于对一般原理的理解
* 翻译模式
    - 是面向实现的语义计算模型

---

### 属性文法

* 在文法G[S]基础上，为文法符号关联有特定意义的 *属性*，并为产生式关联相应的 *语义动作*或 *条件谓词*，称之为 *属性文法*。

对于关联于产生式A->a的语义动作 b:=f(c_1,c_2,...c_k)
* 综合属性
    - 如果b是A的某个属性，则称b是A的一个综合属性
    - 计算综合属性是对 *父结点*的属性赋值，是 *自底向上*传递信息

* 继承属性
    - 如果b是产生式右部某个文件符号X的某个属性，则称b是文法符号X的一个继承属性
    - 计算继承属性是对 *子结点*的属性赋值，是 *自顶向下*传递信息


* S-属性文法
    - 只包含综合属性的属性文法
* L-属性文法
    - 既可以包含综合属性，也可以包含继承属性
    - 要求产生式右端某文法符号的继承属性的计算只取决于该符号左边符号的属性

---

#### 翻译模式

* 翻译模式在形式上类似于属性文法，但允许由{}括起来的予以动作出现在产生式右端的任何位置，以此显示地表达属性计算的次序。

* S-翻译模式
    - 是一种仅涉及综合属性的情形，通常将予以动作集合置于相应产生式右端的末尾
* L-翻译模式
    - 既可以包含综合属性，也可以包含继承属性。
    - 需要满足：
    - 产生式右端某个符号继承属性的计算必须位于该符号之前，其予以动作不访问位于它右边符号的属性
    - 产生式左部非终结符的综合属性的计算只能在所用到属性都计算出来之后进行，通常将相应的语义动作置于产生式的尾部。

# 第八章·静态语义分析和中间代码生成

### 符号表的作用

* 符号表是编译程序用到的最重要的数据之一，几乎在编译的每个阶段每一遍都要涉及符号表
* 在语义分析中，符号表中所登记的内容是进行上下文语义合法性检查的依据

---

### 符号表体现作用域和可见性
* 拥有共同有效范围的符号所在的程序单元就构成了一个作用域。
* 一个作用域可以被另一个作用域包围，称为嵌套的作用域。
* 可见性是指在程序的某一特定点哪些符号是可访问的（即可见的）。
* 每个作用域都有自己的符号表，称为 *多符号表组织*。也可以使所有嵌套的作用域公用一个全局符号表，称为 *单符号表组织*

---

### 静态语义分析
* 符号表最迟要在静态语义分析时候生成
* 基本任务
    - 控制流检查
    - 唯一性检查
    - 名字的上下文相关性检查
    - 类型检查

---

### 中间代码生成
* 中间代码是源程序的不同表示形式，也称为中间表示，作用
    - 用于源语言和目标语言之间的桥梁，避开二者之间较大的语义跨度，使编译程序的逻辑结构更加简单明确。
    - 利于编译程序的重定向。
    - 利于进行与目标机无关的优化
* 拉链与代码回填（重点）

# 第九章·运行时存储组织

### 运行时存储组织的作用与任务
* 编译程序所产生的目标程序本身的大小通常是确定的，一般存放在指定的专用存储区域，即*代码区*

* 目标程序运行过程中需要创建或访问的数据对象将存放在 *数据区*

---

### 程序运行时存储空间的布局

* 保留地址区
    - 专门为目标机体系机构和操作系统保留的内存地址区
* 代码区
* 静态数据区
    - 静态存放全局数据，是普通程序可读可写的区域
* 共享库和分别编译模块区
    - 静态存放共享库模块和分别编译模块的代码和全局数据
* 动态数据区
    - 运行时动态变化的 *堆区*和 *栈区*

---

### 存储分配策略

* 静态存储分配
    - 在编译期间为数据对象分配存储空间，要求在编译期间就可确定数据对象的大小，同时还可以确定数据对象的数目。
* 栈式存储分配
    - 栈区是作为“栈”这样一种数据结构来使用的动态存储区。
* 堆式存储分配

# 第十章·代码优化和目标代码生成

### 基本快、流图和循环

* 基本快
    - 指程序中一个顺序执行的语句讯列，其中只有一个入口语句和一个出口语句。

    - 入口语句类型
        + 程序的第一条语句
        + 条件跳转语句和无条件跳转语句的跳转目标语句
        + 条件跳转语句后面的相邻语句
* 画程序流图
    - 可以为构成程序的基本快增加控制流程信息的有向图。

* 循环
    - 支配检点
        + 到达n点的任一通路都要经过m，称m是n的支配结点，m DOM n。
    - 回边
        + 如果d DOM n，则n->d是流图的一条回边
    - 循环
        + 如果n->d是回边，则到达n却不经过d的通路的所有结点。





